# assembly programming

## Table of Contents
* [background knowledge](#background-knowledge)
* [8086 Model](#8086-model)

## background-knowledge

编译器选择`nasm`,先在`Windows`平台上学习<br>
汇编语言不区分大小写<br>
`;`是汇编语言中的注释

对于Intel8086来说，复位将使代码段寄存器(cs)的内容为0xFFFF,其他所有寄存器的内容都为0x0000,包括指令指针寄存器IP<br>

以Intel 8086为处理器的系统中，ROM占据着整个内存空间顶端的64KB,物理地址范围是0xF0000~0xFFFFF,里面固化了开机时要执行的指令，DRAM占据着较低端的640KB,地址范围是0x00000~0x9FFFF;中间还有一部分，分给了其他外围设备。
8086加电或复位时，CS=0xFFFF,IP=0x0000,故，它取址的第一条指令位于物理地址0xFFFF0,正好位于ROM中，那里固化了开机时需要执行的指令。
处理器取指令执行的自然顺序是从内存的低地址往高地址推进。如果从0xFFF0开始执行，这个位置距离1MB的顶端，只有16个字节的长度，所以0xFFFF0通常是一条跳转指令，它通过改变CS和IP内容，使处理器从ROM中较低地址处开始取指令执行.
`jmp 0xf000:0xe05b`

ROM里的BIOS程序，完成基本硬件检测，诊断，初始化功能。并包含基本软件例程，支持基本输入输出(键盘，屏幕等).

磁头号，从0开始，磁道号，从0开始，扇区号，从1开始。每个扇区，以扇区头开始，包含512字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号，磁头号和扇区号，用来共硬盘定位机构使用，现代硬盘还会在扇区头部包含一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。

硬盘的第一个扇区是0面0道1扇区，这个扇区称为主引导扇区。如果计算机的设置是从硬盘启动，那么，ROM-BIOS将读取硬盘主引导扇区的内容，将它加载到内存地址`ox0000:0x7c00`处，然后用`jmp 0x0000:0x7c00`跳转到那里执行。
主引导扇区的功能是继续从硬盘的其他部分读取更多的内容加以执行。

要访问硬盘，运行中的程序必须至少向硬盘控制器提供4个参数，分别是磁头号，磁道号，扇区号，以及访问意图（读还是写）。硬盘的读写是以扇区为最小单位的，所以无论什么时候，要从硬盘读数据，或者向硬盘写入数据，至少得是一个扇区。

```
采用磁头、磁道和扇区这种模式来访问硬盘的方法称为CHS模式。
LBA(Logical Block Address)逻辑块地址模式是由硬盘控制器在硬件一级上提供的支持，效率很高，兼容性好。LBA模式不考虑扇区的物理位置(磁头号，磁道号)，而是把它们全部组织起来统一编号。

LBA = C * 磁头总数 * 每道扇区数 + H * 每道扇区数 + (S - 1)
LBA表示逻辑扇区号，C、H、S是想求得逻辑扇区号的那个物理扇区所在的磁道、磁头和扇区号。
```

## 8086-Model

ROM-BIOS将试图读取硬盘的0面0道1扇区。传统上，这就是主引导扇区(Main Boot Sector MBR)
一个有效的主引导扇区，其最后两个字节应当是0x55和0xAA.ROM-BIOS程序，首先检测这两个标志，如果主引导扇区有效，则以一个段间转移指令`jmp 0x0000:0x7c00`跳到那里继续执行。

显示器，显卡，显存
黑色和白色只需要1个比特就能够表示。现在最流行的，是用24个比特，即3个字节，来对应一个像素。2^24=16777216,所以在这种模式下，同屏可以显示16777216种颜色，称为真彩色。

显示图片还是显示文字，对显示器来说，没有区别。为了方便，创造了ASCII码，用一个数来表示一个字符。将字符的代码存放到显存中，便可以在屏幕上显示文字。
传统上，专门用于显示字符的工作方式称为文本模式，文本模式和图形模式是显卡的两种基本工作模式，可用指令访问显卡，设置他的显示模式。不同的工作模式下，显卡对显存的内容的解释是不同的。

为了提高访问显存的效率，把显存映射到处理器可以直接访问的地址空间里，也就是内存空间里。

8086可以访问1MB内存，其中0x00000~0x9FFFF属于常规内存，由内存条提供；0xF0000~0xFFFFF由主板上的一个芯片提供，即ROM-BIOS。
中间的0xA0000~0xEFFFF，这段地址空间由特定的外围设备来提供，其中就包括显卡。
由于历史原因，所有个人计算机上的显卡，在加电自检后，都会把自己初始化到80*25的文本模式。一直以来，0xB8000~0xBFFFF是留给显卡的。

文本模式下的显存的起始物理地址为0xB8000,这段内存可以看成是段地址为0xB800,偏移地址从0x0000延伸到0xFFFF的区域。
访问内存可以使用段寄存器DS,也可以使用ES.
```
Intel处理器不允许将一个立即数传送到段寄存器，它只允许：
mov 段寄存器, 通用寄存器
mov 段寄存器，内存单元
```

屏幕上每个字符对应着显存中的两个连续字节，前一个是字符的ASCII码，后一个是字符的显示属性，包括字符颜色（前景色）和底色（背景色）

```
背景色    前景色
K R G B  I R G B
低4位定义前景色，高4位定义背景色。色彩由R,G,B这3位决定。K是闪烁位，为0时不闪烁，为1时闪烁。I是亮度位，为0时正常亮度，为1时呈高亮。

0x07为黑底白字，无闪烁，无加亮。

屏幕一片漆黑时，显示的是黑底白字的空白字符(0x20) Space
```

```
在指令中使用字符字面值时，需要用引号引起来。
一般情况下没有附加任何指示，段地址默认在段寄存器DS中.
mov byte [0x00], 'L'

因为目的操作数给出的是一个内存地址，我们要用源操作数来修改这个地址里的内容，所以，目的操作数必须用方括号围起来，表明它是一个地址。

关键字byte用来修饰目的操作数，指出本次传送是以字节的方式进行的。编译器无法搞懂你的真实意图时，必须用byte或word进行修饰。 如果明确的，则不需要进行修饰。如:
mov [0x00],AL   ;按字节操作
mov AX, [0x02]  ;按字操作
```
```
标号

汇编地址是在源程序编译期间，编译器为每条指令确定的汇编位置(Assembly Position),也就是每条指令相对于整个程序开头的偏移量，以字节计。当编译后的程序装入物理内存后，它又是该指令在内存段内的偏移地址。

每条指令前，都可以拥有一个标号，以代表和指示该指令的汇编地址。因为我们自己计算和跟踪每条指令的汇编地址是及其困难的。

如 infi: jmp near infi
行首带冒号的是标号infi,标号之后的冒号是可选的. 标号并不是必须的，只有在我们需要引用某条指令的汇编地址时，才使用标号。

标号可以由字母，数字，_, $, #, @, ~, ., ?组成，但必须以字母，.,_和?中的任意一个打头
```

